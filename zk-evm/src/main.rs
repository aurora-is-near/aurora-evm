use aurora_evm_jsontests::types::StateTestCase;
use clap::{arg, command, value_parser};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};

use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use std::path::{Path, PathBuf};

// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{ZK_EVM_ELF, ZK_EVM_ID};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let input = run_cli();
    let (receipt, _) = execute_evm(input);

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(ZK_EVM_ID).unwrap();
}

fn execute_evm(tests_suit: String) -> (Receipt, String) {
    let env = ExecutorEnv::builder()
        .write(&tests_suit)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, ZK_EVM_ELF).unwrap().receipt;
    let output = receipt.journal.decode().unwrap();
    (receipt, output)
}

fn get_tests_suite(file_name: &Path) -> String {
    let file = File::open(file_name).expect("Open file failed");
    let reader = BufReader::new(file);

    // We parse the JSON test cases to verify is it deserialized correctly
    let _ = serde_json::from_reader::<_, HashMap<String, StateTestCase>>(reader)
        .expect("Parse test cases failed");
    std::fs::read_to_string(file_name).unwrap()
}

fn run_cli() -> String {
    let matches = command!()
        .version(env!("CARGO_PKG_VERSION"))
        .arg(
            arg!(<PATH> "JSON file for tests run")
                .value_parser(value_parser!(PathBuf))
                .required(true),
        )
        .get_matches();

    let src_name = matches.get_one::<PathBuf>("PATH").expect("PATH required");

    let path = Path::new(src_name);

    assert!(
        path.exists(),
        "data source does not exist: {}",
        path.display()
    );
    assert!(path.is_file(), "Path is not a file: {}", path.display());

    get_tests_suite(path)
}
